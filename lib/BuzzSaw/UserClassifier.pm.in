package BuzzSaw::UserClassifier; # -*-perl-*-
use strict;
use warnings;

# $Id: Kernel.pm.in 21339 2012-07-11 14:01:02Z squinney@INF.ED.AC.UK $
# $Source:$
# $Revision: 21339 $
# $HeadURL: https://svn.lcfg.org/svn/source/trunk/BuzzSaw/lib/BuzzSaw/Filter/Kernel.pm.in $
# $Date: 2012-07-11 15:01:02 +0100 (Wed, 11 Jul 2012) $

our $VERSION = '@LCFG_VERSION@';

use IO::File ();

use Moose;
use MooseX::Types::Moose qw(Int Str);
use Moose::Util::TypeConstraints;

subtype 'NonPersonalUsers'
  => as 'HashRef';

coerce 'NonPersonalUsers'
  => from 'Str',
  => via { _load_users($_) };

has 'people' => (
  isa     => Int,
  is      => 'ro',
  lazy    => 1,
  default => sub { (getgrnam('people'))[2] },
);

has 'nonpersonal_users' => (
  traits  => ['Hash'],
  isa     => 'NonPersonalUsers',
  is      => 'ro',
  lazy    => 1,
  coerce  => 1,
  default => sub { {} },
  handles => {
    in_nonpersonal_users => 'exists',
  },
);

no Moose;
__PACKAGE__->meta->make_immutable;

sub _load_users {
  my ($file) = @_;

  my %users;

  my $fh = IO::File->new($file)
    or die "Could not open $file: $!\n";

  while( defined(my $line = <$fh> ) ) {
    chomp $line;

    if ( $line =~ m/^\s*$/ || $line =~ m/^\#/ ) {
      next;
    }

    $line =~ s/^\s+//;
    $line =~ s/\s+$//;

    $users{$line} = 1;
  }

  return \%users;
}

sub is_user {
  my ( $self, $username ) = @_;

  my $uid = getpwnam($username);

  return (defined $uid ? 1 : 0);
}

sub is_person {
  my ( $self, $username ) = @_;

  if ( $self->is_user($username) ) {
    my $gid = (getpwnam($username))[3];

    return ( $gid == $self->people ? 1 : 0 );
  }

  return 0;
}

sub looks_like_person {
  my ( $self, $username ) = @_;

  # This is specific to UoE. Might be worth moving this list of
  # regular expressions into a list attribute.

  # student usernames are 's' followed by 7 digits
  #
  # Assume these are typos:
  #   A double 's' to start
  #   Anything starting 's' followed by 5, 6 or more than 7 digits
  #   Exactly 7 digits (but not initial 's')
  #   
  # Also matching anything which looks like a visitor account

  if ( $username =~ m/^s{1,2}[0-9]{5}/io ||
       $username =~ m/^[0-9]{7}$/o      ||
       $username =~ m/^v[0-9][a-z]+[0-9]?$/io ) {
    return 1;
  }

  return 0;
}

sub is_root {
  my ( $self, $username ) = @_;

  # matches root, r00t, r0ot, ROOT, etc
  if ( $username =~ m/^r[o0]{2}t$/io )  {
    return 1;
  }

  return 0;
}

sub is_nonpersonal {
  my ( $self, $username ) = @_;

  if ( $self->is_person($username) || $self->looks_like_person($username) ) {
    return 0;
  }

  # Check to see if the user exists (but is not a member of the
  # 'people' group as we have already seen)

  if ( $self->is_user($username) ) {
    return 1;
  }

  # Finally check to see if it is in the nonpersonal dict

  return $self->in_nonpersonal_users($username);
}

sub mangle_username {
  my ( $self, $username ) = @_;

  $username =~ s/^@@@//;

  $username = lc $username;

  if ( $username eq 'tmp' ) {
    $username = 'temp';
  }

  my @startlike = ( 'account','admin','backup','cacti','cvs',
                    'ftp','gast','guest','mysql','nagios','oracle',
                    'postgres','shoutcast','smb','spam','support',
                    'sysadm',
                    'teamspeak','newsreaderg','data','usr','team',
                    'marketing','monitoring','svn','feedback',
                    'telnet','temp','test','web','www' );

  for my $entry (@startlike) {
    if ( index($username, $entry) == 0 ) {
      $username = $entry;
      last;
    }
  }

  return $username;
}

sub classify {
  my ( $self, $username ) = @_;

  my $user_type = 'others';

  if ( $self->is_root($username) ) {
    $user_type = 'root';
  } elsif ( $self->is_person($username) ||
            $self->looks_like_person($username) ) {
    $user_type = 'real';
  } elsif ( $self->is_nonpersonal($username) ) {
    $user_type = 'nonperson';
  }

  return $user_type;
}

1;
__END__
