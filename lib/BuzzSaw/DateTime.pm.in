package BuzzSaw::DateTime;
use strict;
use warnings;

use base 'DateTime';

use Date::Parse ();
use DateTime::Duration ();

sub from_date_string {
    my ( $class, $date_string ) = @_;

    my $now = $class->now();

    # Ensure we are using the current local timezone
    $now->set_time_zone('local');

    my $dt;
    if ( $date_string eq 'now' ) {
        $dt = $now;
    } elsif ( $date_string eq 'today' ) {
        $dt = $now->truncate( to => 'day' );
        $dt->set_second(1);
    } elsif ( $date_string eq 'recent' ) {
        my $dur = DateTime::Duration->new( minutes => 10 );
        $dt = $now - $dur;
    } elsif ( $date_string eq 'yesterday' ) {
        $dt = $now->truncate( to => 'day' );
        $dt->set_second(1);
        my $dur = DateTime::Duration->new( days => 1 );
        $dt = $now - $dur;
    } elsif ( $date_string =~ m/^this-(week|month|year)$/ ) {
        $dt = $now->truncate( to => $1 );
        $dt->set_second(1);
    } elsif ( $date_string eq 'week-ago' ) {
        my $dur = DateTime::Duration->new( days => 7 );
        $dt = $now - $dur;
    } elsif ( $date_string =~ m/^\d+$/ ) {
        $dt = $class->from_epoch( epoch => $date_string );
        $dt->set_time_zone('local');
    } else { # throw it at Date::Parse
        my ( $ss, $mm, $hh, $day, $month, $year, $zone )
          = Date::Parse::strptime($date_string);
        $zone //= 'local';
        $month += 1; # Date::Parse counts from zero
        $year  += 1900;

        $dt = $class->new( second    => int($ss),
                           minute    => $mm,
                           hour      => $hh,
                           day       => $day,
                           month     => $month,
                           year      => $year,
                           time_zone => $zone );

    }

    return $dt;
}

1;

__END__
