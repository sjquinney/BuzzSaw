package BuzzSaw::Report;
use strict;
use warnings;

use BuzzSaw::DB;
use BuzzSaw::DateTime;
use MIME::Lite ();
use Template ();

use Moose;
use Moose::Util::TypeConstraints;

class_type('BuzzSaw::DateTime');

coerce 'BuzzSaw::DateTime'
    => from 'Int'
    => via { my $dt = BuzzSaw::DateTime->from_epoch( epoch => $_ );
             $dt->set_time_zone('local');
             return $dt; };

coerce 'BuzzSaw::DateTime'
    => from 'Str'
    => via { BuzzSaw::DateTime->from_date_string($_) };

coerce 'BuzzSaw::DateTime'
    => from 'HashRef'
    => via { BuzzSaw::DateTime->new( time_zone => 'local', %{$_} ) };

has 'catalogue' => (
    is       => 'ro',
    isa      => 'BuzzSaw::DB',
    required => 1,
    default  => sub { BuzzSaw::DB->new_with_config() },
    lazy     => 1,
);

has 'name' => (
  is       => 'ro',
  isa      => 'Str',
  required => 1,
  default => sub {
    my $class = shift @_;
    my $name = ( split /::/, $class->meta->name )[-1];
    return $name;
  },
);

has 'email_to' => (
  is        => 'ro',
  isa       => 'Str',
  predicate => 'send_by_email',
);

has 'email_from' => (
  is        => 'ro',
  isa       => 'Str',
  predicate => 'has_email_from',
);

has 'email_subject' => (
  is       => 'ro',
  isa      => 'Str',
  default  => sub { my $self = shift @_;
                    'BuzzSaw Report - ' . $self->name },
  required => 1,
  lazy     => 1,
);

has 'template' => (
  is       => 'ro',
  isa      => 'Str',
  required => 1,
  default => sub {
    my $class = shift @_;
    my $mod = ( split /::/, $class->meta->name )[-1];
    my $template = lc($mod) . '.tt';
    return $template;
  },
);

has 'tmpldir' => (
    is       => 'ro',
    isa      => 'ArrayRef[Str]',
    required => 1,
    default  => sub { ['/usr/share/buzzsaw/templates/reports',
                       '/usr/share/buzzsaw/templates'] },
);

has 'start' => (
    is       => 'ro',
    isa      => 'BuzzSaw::DateTime',
    required => 1,
    coerce   => 1,
    default  => sub { 'yesterday' },
);

has 'end' => (
    is       => 'ro',
    isa      => 'BuzzSaw::DateTime',
    required => 1,
    coerce   => 1,
    default  => sub { 'today' },
);

has 'tags' => (
  traits    => ['Array'],
  is        => 'ro',
  isa       => 'ArrayRef[Str]',
  default   => sub { [] },
  handles   => {
    has_tags  => 'count',
    tags_list => 'elements',
  },
);

no Moose;
__PACKAGE__->meta->make_immutable;

sub BUILD {
    my ($self) = @_;

    my $diff = $self->end - $self->start;
    if ( $diff->is_negative ) {
        die "Error: Start date/time is later than end date/time\n"
    }
    return;
}

sub generate {
  my ($self) = @_;

  my @events = $self->find_events();

  my %results = $self->process_events(@events);

  my $text = $self->process_template( \%results, \@events );

  if ( $self->send_by_email ) {
    $self->send_email($text);
  } else {
    print $text;
  }

  return;
}

sub send_email {
  my ( $self, $text ) = @_;

  my @args = (
    To       => $self->email_to,
    Subject  => $self->email_subject,
    Data     => $text,
  );

  if ( $self->has_email_from ) {
    push @args, ( From => $self->email_from );
  }

  my $msg = MIME::Lite->new(@args);

  my $send_ok = $msg->send();
  if ( !$send_ok ) {
    warn "Failed to send report email";
  }

  return;
}

sub process_template {
  my ( $self, $results, $events ) = @_;

  my $tt = Template->new(
    {
      INCLUDE_PATH => $self->tmpldir,
    }
  ) or die "$Template::ERROR\n";

  my %vars = (
    results => $results,
    events  => $events,
    params  => {
      start => $self->start,
      end   => $self->end,
      tags  => $self->tags,
    },
  );

  my $output;
  $tt->process( $self->template, \%vars, \$output )
    or die $tt->error();

  return $output;
}

sub process_events {
  my ( $self, @events ) = @_;

  my %vars;


  return %vars;
}

sub find_events {
  my ($self) = @_;

  my $schema = $self->catalogue->schema;
  my $events_rs = $schema->resultset('Event');

  # Find events within the required time range

  my $dtf = $schema->storage->datetime_parser;

  my %query = (
    logtime => [
      -and => { '>=', $dtf->format_datetime($self->start) },
              { '<=', $dtf->format_datetime($self->end)   },
    ],
  );

  my %attrs = ( order_by => 'logtime' );

  if ( $self->has_tags ) {

    # join onto the tag table and search for events with the specified tags

    $attrs{join}     = 'tags';

    $query{'tags.name'} = { -in => $self->tags };
  }

  my @events = $events_rs->search( \%query, \%attrs );

  return @events;
}

1;
__END__
