package BuzzSaw::Report;
use strict;
use warnings;

# $Id$
# $Source:$
# $Revision$
# $HeadURL$
# $Date$

our $VERSION = '@LCFG_VERSION@';

use BuzzSaw::DB;
use BuzzSaw::DateTime;
use BuzzSaw::Types qw(BuzzSawDB BuzzSawDateTime);

use MIME::Lite ();
use Template ();

use Moose;
use MooseX::Types::EmailAddress qw(EmailAddress EmailAddressList);
use MooseX::Types::Moose qw(ArrayRef Str);

has 'db' => (
  is       => 'rw',
  isa      => BuzzSawDB,
  coerce   => 1,
  required => 1,
  lazy     => 1,
  default  => sub { BuzzSaw::DB->new_with_config() },
);

has 'name' => (
  is       => 'ro',
  isa      => Str,
  required => 1,
  default  => sub {
    my $class = shift @_;
    my $name = ( split /::/, $class->meta->name )[-1];
    return $name;
  },
);

has 'email_to' => (
  traits    => ['Array'],
  is        => 'ro',
  isa       => EmailAddressList,
  coerce    => 1,
  default   => sub { [] },
  handles   => {
    'send_by_email'      => 'count',
    'email_to_addresses' => 'elements',
  },
);

has 'email_from' => (
  is        => 'ro',
  isa       => EmailAddress,
  predicate => 'has_email_from',
);

has 'email_subject' => (
  is       => 'ro',
  isa      => Str,
  default  => sub { my $self = shift @_;
                    'BuzzSaw Report - ' . $self->name },
  required => 1,
  lazy     => 1,
);

has 'template' => (
  is       => 'ro',
  isa      => Str,
  required => 1,
  default => sub {
    my $class = shift @_;
    my $mod = ( split /::/, $class->meta->name )[-1];
    my $template = lc($mod) . '.tt';
    return $template;
  },
);

has 'tmpldirs' => (
    is       => 'ro',
    isa      => ArrayRef[Str],
    required => 1,
    default  => sub { [ '/usr/share/buzzsaw/templates/reports',
                        '/usr/share/buzzsaw/templates' ] },
);

has 'start' => (
    is       => 'ro',
    isa      => BuzzSawDateTime,
    required => 1,
    coerce   => 1,
    default  => sub { 'yesterday' },
);

has 'end' => (
    is       => 'ro',
    isa      => BuzzSawDateTime,
    required => 1,
    coerce   => 1,
    default  => sub { 'today' },
);

has 'tags' => (
  traits    => ['Array'],
  is        => 'ro',
  isa       => ArrayRef[Str],
  default   => sub { [] },
  handles   => {
    has_tags  => 'count',
    tags_list => 'elements',
  },
);

no Moose;
__PACKAGE__->meta->make_immutable;

sub BUILD {
    my ($self) = @_;

    my $diff = $self->end - $self->start;
    if ( $diff->is_negative ) {
        die "Error: Start date/time is later than end date/time\n"
    }
    return;
}

sub generate {
  my ($self) = @_;

  my @events = $self->find_events();

  my %results = $self->process_events(@events);

  my $text = $self->process_template( \%results, \@events );

  if ( $self->send_by_email ) {
    $self->send_email($text);
  } else {
    print $text;
  }

  return;
}

sub send_email {
  my ( $self, $text ) = @_;

  my ( $to, @cc ) = $self->email_to_addresses;

  my @args = (
    To       => $to,
    Subject  => $self->email_subject,
    Data     => $text,
  );

  if ( scalar @cc > 0 ) {
    my $cc = join q{, }, @cc;
    push @args, ( Cc => $cc );
  }

  if ( $self->has_email_from ) {
    push @args, ( From => $self->email_from );
  }

  my $msg = MIME::Lite->new(@args);

  my $send_ok = $msg->send();
  if ( !$send_ok ) {
    warn "Failed to send report email";
  }

  return;
}

sub process_template {
  my ( $self, $results, $events ) = @_;

  my $tt = Template->new(
    {
      INCLUDE_PATH => $self->tmpldirs,
    }
  ) or die "$Template::ERROR\n";

  my %vars = (
    results => $results,
    events  => $events,
    params  => {
      start => $self->start,
      end   => $self->end,
      tags  => $self->tags,
    },
  );

  my $output;
  $tt->process( $self->template, \%vars, \$output )
    or die $tt->error();

  return $output;
}

sub process_events {
  my ( $self, @events ) = @_;

  my %vars;


  return %vars;
}

sub find_events {
  my ($self) = @_;

  my $schema = $self->db->schema;
  my $events_rs = $schema->resultset('Event');

  # Find events within the required time range

  my $dtf = $schema->storage->datetime_parser;

  my %query = (
    logtime => [
      -and => { '>=', $dtf->format_datetime($self->start) },
              { '<=', $dtf->format_datetime($self->end)   },
    ],
  );

  my %attrs = ( order_by => 'logtime' );

  if ( $self->has_tags ) {

    # join onto the tag table and search for events with the specified tags

    $attrs{join}     = 'tags';

    $query{'tags.name'} = { -in => $self->tags };
  }

  my @events = $events_rs->search( \%query, \%attrs );

  return @events;
}

1;
__END__
